/**
 * ?浏览器缓存
 * ^览器缓存保存着用户通过 HTTP 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求。
 * ^通俗的说，就是在你访问过一次某个网站之后，这个站点的文字、图片等所有资源都被下载到本地了，
 * ^下次再访问该网站时判断是否满足缓存条件，如果满足就不用再花费时间去等待资源的获取了。
 * ! 浏览器在加载资源时，会先判断是否命中强缓存再验证是命中协商缓存
 * 
 * ?强缓存
 * * 1.查看 header 头中的 Expire 和 Cache-control 来判断是否满足规则；
 * * 2.如果满足规则，就返回缓存的数据；
 * * 3.如果不满足规则，就向服务器发送请求；
 * * 4.服务器返回数据；
 * * 5.将新数据存入缓存。
 * 
 * _i Expire 这个字段表示缓存到期时间
 * _b 通过设置 Expire 来设置缓存有一个致命缺点：
 * _b 可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢
 * _i Cache-Control max-age 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。
 * 
 * !现在基本上都会同时设置 Expire 和 Cache-Control ，Cache-Control 的优先级别更高
 * 
 * ?协商缓存
 * 
 * * 1. 把资源标识，比如 If-Modify-Since 或 Etag 发送到服务器，确认资源是否更新；
 * * 2. 如果资源未更新，请求响应返回的http状态为 304 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存;
 * * 3. 如果资源已经更新，返回新的数据；
 * * 4. 将新数据存入缓存。
 * 
 * _i Last-Modified，If-Modified-Since
 * 浏览器第一次请求资源的时候，服务器返回的 header 上会带有一个 Last-Modified 字段，表示资源最后修改的时间
 * 同样的，这是一个 GMT 的绝对时间。
 * 当浏览器再次请求该资源时，请求头中会带有一个 If-Modified-Since 字段，这个值是第一次请求返回的 Last-Modified 的值。
 * 服务器收到这个请求后，将 If-Modified-Since 和当前的 Last-Modified 进行对比。如果相等，则说明资源未修改，返回 304，浏览器使用本地缓存。
 * _b 最小单位是秒。也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化
 * _b 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为
 * 
 * 
 * _i Etag
 * Etag 一般是由文件内容 hash 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 Etag 发生改变。
 * 
 * ! Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304。**
 */