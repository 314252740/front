/**
 * _s https://juejin.cn/post/6844903844216832007#heading-7
 * ?  HTTP协议简介
 * ^ HTTP协议定义Web客户端如何从Web服务器请求Web页面，
 * ^ 以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。
 * ^ 客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，
 * ^ 响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据
 * *
 * 
 * ?  HTTP版本
 * * HTTP/1.0
 * ^最早的http只是使用在一些较为简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的TCP链接，收到响应之后立即断开连接。
 * 
 * *HTTP/1.1
 * ^HTTP/1.1 引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等
 * ^HTTP/1.1 允许范围请求，即在请求头中加入Range头部
 * ^HTTP/1.1 的请求消息和响应消息都必须包含Host头部，以区分同一个物理主机中的不同虚拟主机的域名
 * ^HTTP/1.1 默认开启持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
 * 
 * *HTTP/2.0
 * ^在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。
 * ^帧代表数据传输的最小的单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。
 * ^这里有个chrome扩展程序，可以方便的查看当前网站的HTTP请求版本（安装后在chrome开发工具-Network-在Name/Size/Time表格头右键选择Procotol，即可查看协议版本）。

 * ^新的二进制格式： HTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。
 * ^              二进制则不同，只识别0和1的组合。基于这种考虑HTTP/2.0的协议解析采用二进制格式，方便且强大。
 * ^多路复用： HTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，
 * ^         服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，
 * ^         每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行,极大的提高传输性能。
 * ^头部压缩： HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0使用encoder来减少需要传输的头部大小，
 * ^         通讯双方各自cache一份头部 fields表，既避免了重复头部的传输，又减小了需要传输的大小。
 * ^服务端推送： 这里的服务端推送指把客户端所需要的css/js/img资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。
 * 
 * * HTTP/3.0
 * ^  HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，
 * ^     也就导致了后面的所有数据都被阻塞了。
 * ^  QUIC 基于 UDP，但是UDP本身存在不稳定性等诸多问题，所以QUIC在UDP的基础上新增了很多功能，
 * ^     比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。优点诸多，参考这里：
 * ^ 避免包阻塞： 多个流的数据包在TCP连接上传输时，若一个流中的数据包传输出现问题，TCP需要等待该包重传后，才能继续传输其它流的数据包。
 *  ^   但在基于UDP的QUIC协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。
 * ^ 快速重启会话： 普通基于tcp的连接，是基于两端的ip和端口和协议来建立的。
 * ^    在网络切换场景，例如手机端切换了无线网，使用4G网络，会改变本身的ip，这就导致tcp连接必须重新创建。
 * ^    而QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据。
 * 
 * ?  HTTP报文
 * ^请求报文 是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息等）和内容实体（用户信息和资源信息等，可为空）构成。
 * 
 * 
 * ?  Web服务器
 * ^ HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。
 * ^ 利用虚拟主机的功能，可以在一台物理服务器（一个IP地址）上虚拟出多个主机，
 * ^ 每个主机映射一个独立的域名。
 * ^ 因此，当用户访问域名http://www.laogeng.com/时，DNS域名系统会将其解析成IP地址，
 * ^ 根据IP找到物理服务器，然后再通过请求首部的HOST字段（现在知道HOST为什么是HTTP/1.1强制要求携带的了吧）确认对应的虚拟主机。
 * 
 * 
 * ?  HTTPS
 * *HTTPS基于HTTP协议，通过SSL或TLS（可以看作SSL3.0）提供加密处理数据、验证对方身份以及数据完整性保护。
 * !特点
* * 1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容
* * 1. 验证身份：通过证书认证客户端访问的是自己的服务器
* * 1. 保护数据完整性：防止传输的内容被中间人冒充或者篡改
 * ^ HTTP本身没有任何保密性，所以HTTP传输的数据相当于都是在网上在以明文的方式裸奔。为了解决这个问题，出现了各种加密技术
 *
 * * 对称加密
 * ^唯一密钥key1可用来加密也可用来解密。这样的加密需要双方都拥有密钥key1，如果第一次传输密钥被第三方截获就玩完
 * 
 * * 非对称加密
 * ^公钥key3和私钥key2都可用于对应的加密和解密，即可用公钥加密私钥解密，也可用私钥加密公钥解密。服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布供任何人使用。客户端的明文通过公钥加密后的密文需要用私钥解密。非对称密钥在加密和解密的过程的使用的密钥是不同的密钥，加密和解密是不对称的，所以称之为非对称加密。与对称密钥加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的
 * 
 * * 混合加密
 * ^服务端先用非对称加密的私钥key2加密对称加密的密钥key1并传给客户端，客户端用非对称加密的公钥key3解密出对称加密的密钥key1，双方都有了密钥key1，开始利用key1加密通信。缺点：中间人可以自己生成非对称加密公钥替换掉服务端公钥发送给客户端，而此时客户端并无法验证公钥的可信性
 * 
 * * SSL
 * ^首先需要从证书认证机构申请证书（证书中含有证书签名和服务端公钥key3）。在客户端发起HTTP请求时，服务端将证书发送给客户端。客户端认证证书的真伪，然后解密出服务端公钥key3，用公钥加密自己生成的对称加密密钥key1并传给服务端，最后利用key1加密进行通话。至于安全性，由于私钥是机构的，可以避免第三方伪造证书。并且就算得到了服务端公钥，也无法解密出公钥key3加密过的对称加密密钥key1
 * 
 * !HTTPS和HTTP的区别主要如下：
 * * HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
 * * HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
 * * HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
 * * http的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比http协议安全。
 * ?  Web安全防范
 * * 1. XSS 攻击
 * ^ XSS 攻击全称跨站脚本攻击，是利用html可以执行<script>alert(1)</script>的特性，想尽办法将脚本注入页面中的攻击手段
 * ! 1.1 通过修改浏览器URL导致脚本被注入到页面, 会被chrome浏览器自动防御攻击（但最好还是手动也防御一下）
 * ! 1.2 通过输入框将脚本代码注入数据库, 
 * _b const xss = require('xss')
 * _b let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
 * _b -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
 * 
 * * 2. CSRF 攻击( 跨站请求伪造 )
 * _b eg. 假如有个加关注的GET接口，id参数是关注人Id，如下：
 * _b https://juejin.im?id=5cd0438c6fb9a031ec6d3ab2
 * _b 那我只需要在我的一个页面里面写一个img标签：
 * _b <img src="https://juejin.im?id=5cd0438c6fb9a031ec6d3ab2" />
 * ^ 那么只要有已经登录掘金的用户打开我这个页面，就会自动关注我。
 * ^ 就算是改为POST请求，也可以通过在页面使用form表单提交的方式自动关注。
 * ^ CSRF攻击是源于Web的隐式身份验证机制！Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，
 * ^ 但却无法保证该请求是用户批准发送的。CSRF攻击的问题一般是由服务端解决，防范 CSRF 攻击可以遵循以下几种规则：
 * _b 1. Get 请求不用于对数据进行修改
 * _b 2.Cookie设置HTTP Only
 * _b 3.接口设置禁止跨域
 * _b 4.请求时附带验证信息，比如验证码或者 Token
 * 
 * * 3. 点击劫持
 * ^点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌入自己的网页中，并将 iframe 设置为透明，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面
 * ^还是让后端大佬解决，使用一个HTTP响应头——X-Frame-Options。X-Frame-Options可以说是为了解决点击劫持而生的，它有三个可选的值：
 * _b DENY：浏览器会拒绝当前页面加载任何frame页面；
 * _b SAMEORIGIN：frame页面的地址只能为同源域名下的页面；
 * _b ALLOW-FROM origin：允许frame加载的页面地址；
 * 
 * * 4. 中间人攻击
 * ^ 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。
 * ^攻击者不仅能获得双方的通信信息，还能修改通信信息。中间人攻击的本质是客户端和服务端之间的认证和信任问题
 * _b 对称加密、非对称加密、混合加密技术都没有有效防止中间人攻击，因为中间人可以截取首次传输的密钥并偷天换日，而客户端或服务端并无法得知。
 * _b HTTPS作为防止中间人攻击的终极手段，引入证书机制解决了客户端和服务端的信任问题，从而较为有效的防止了中间人攻击。
 */