/**
 * _p https://juejin.cn/post/6844903685563105293
 * ? tcp标识位说明
 * * URG(urgent紧急)：为1时，表示紧急指针有效
 * * ACK(acknowledgement 确认)：确认标识，连接建立成功后，总为1。为1时确认号有效
 * * PSH(push传送)：接收方应尽快把这个报文交给应用层
 * * RST(reset重置)：复位标识，重建连接
 * * SYN(synchronous建立联机)：建立新连接时，该位为0
 * * FIN(finish结束)：关闭连接标识
 * *Sequence number(顺序号码)
 * *Acknowledge number(确认号码)
 * 
 * ? why 三次握手
 * *tcp连接是全双工的，数据在两个方向上能同时传递。
 * *所以要确保双方，同时能发数据和收数据
 * *第一次握手：证明了发送方能发数据
 * *第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据
 * *第三次握手：确保了发送方能收数据
 * *实际上是四个维度的信息交换，不过中间两步合并为一次握手了。
 * *四次握手浪费，两次握手不能保证“双方同时具备收发功能”
 * 
 * ? why 四次挥手
 * *因为tcp连接是全双工的，数据在两个方向上能同时传递。
 * *同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。
 * *因此每个方向都要单独关闭，且收到关系通知需要发送确认回复
 * 
 * ? why 支持半关闭
 * *客户端需要通知服务端，它的数据已经传输完毕
 * *同时仍要接收来自服务端的数据
 * *使用半关闭的单连接效率要比使用两个tcp连接更好
 * 
 * ? why 状态
 * *服务端等待客户端连接时，处于Listen监听状态
 * *客户端主动打开请求，发送SYN时处于SYN_SENT发送状态
 * *客户端收到syn和ack，并回复ack时，处与Established状态等待发送报文
 * *服务端收到ack确认后，也处于Established状态等待发送报文
 * *客户端发送fin后，处于fin_wait_1状态
 * *服务端收到fin并发送ack时，处于close_wait状态
 * *客户端收到ack确认后，处于fin_wait_2状态
 * *服务端发送fin后，处于last_ack状态
 * *客户端收到fin后发送ack，处于time_wait状态
 * *服务端收到ack后，处于closed状态
 * 
 * ? time_wait状态
 * *也称为2MSL等待状态，MSL=Maximum Segment LifetIme，报文段最大生存时间，根据不同的tcp实现自行设定。常用值为30s，1min，2min。linux一般为30s。
 * *主动关闭的一方发送最后一个ack所处的状态
 * *这个状态必须维持2MSL等待时间
 * _i 为什么需要这么做？
 * _s 设想一个场景，最后这个ack丢失了，接收方没有收到
 * _s这时候接收方会重新发送fin给发送方
 * _s这个等待时间就是为了防止这种情况发生，让发送方重新发送ack
 * _s总结：预留足够的时间给接收端收ack。同时保证，这个连接不会和后续的连接乱套（有些路由器会缓存数据包）
 * _i这么做的后果
 * _s在这2MSL等待时间内，该连接（socket，ip+port）将不能被使用
 * _s很多时候linux上报too many open files，说端口不够用了，就需要检查一些代码里面是不是创建大量的socket连接，而这些socket连接并不是关闭后就立马释放的
 * _s客户端连接服务器的时候，一般不指定客户端的端口。因为客户端关闭然后立马启动，按照理论来说是会提示端口被占用。同样的道理，主动关闭服务器，2MSL时间内立马启动是会报端口被占用的错误
 * _s多并发的短连接情况下，会出现大量的Time_wait状态。这两个参数可以解决问题，但是它违背了tcp协议，是有风险的。参数为：tcp_tw_reuse和tcp_tw_recycle
 * _s如果是服务端开发，可设置keep-alive，让客户端主动关闭连接解决这个问题
 * 
 * 
 * ? 同时打开
 * *两个应用程序同时执行主动打开，称为“同时打开“
 * *这种情况极少发生
 * *两端同时发送SYN，同时进入SYN_SENT状态
 * *打开一条连接而不是两条
 * *要进行四次报文交换过程，“四次握手”
 * 
 * ?同时关闭
 * *双方同时执行主动关闭
 * *进行四次报文交换
 * *状态和正常关闭不一样
 * 
 * 
 */