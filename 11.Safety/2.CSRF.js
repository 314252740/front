/**
 * ? CSRF
 * _i（Cross-site request forgery）跨站请求伪造 
 * ^攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。
 * ^利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
 * 
 * ?攻击流程
 * * 1. 受害者登录A站点，并保留了登录凭证（Cookie）。
 * * 2. 攻击者诱导受害者访问了站点B。
 * * 3. 站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。
 * * 4. 站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。
 * * 5. 站点A以受害者的名义执行了站点B的请求。
 * * 6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。
 * 
 * 
 * ?  防御CSRF
 * * 1. 添加验证码(体验不好)
 * ^ 验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。
 * 
 * * 2. 判断请求的来源：检测Referer(并不安全，Referer可以被更改)
 * ^ `Referer` 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 `Referer` 本身是可以被修改的，因为不能仅依赖于  `Referer`
 * 
 * * 3. 使用Token(主流)
 * ^ CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。
 * ^ 服务端给用户生成一个token，加密后传递给用户
 * ^ 用户在提交请求时，需要携带这个token
 * ^ 服务端验证token是否正确
 * 
 * * 4. Samesite Cookie属性
 * ^ Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */